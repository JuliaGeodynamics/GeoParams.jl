using Test, GeoParams, StaticArrays, LaTeXStrings
import ForwardDiff.derivative
@testset "Density.jl" begin

    #Set alias for density function
    if !isdefined(Main, :GeoParamsAliases)
        eval(:(@use GeoParamsAliases density = ρ))
    end

    #Make sure that structs are isbits
    x = ConstantDensity()
    @test isbits(x)
    @test param_info(x).Equation === L"$\rho = cst$"
    @test isdimensional(x) === true

    x = PT_Density()
    @test isbits(x)
    @test param_info(x).Equation === L"$\rho = \rho_0(1.0-\alpha (T-T_0) + \beta (P-P_0)$"
    @test isdimensional(x) === true

    x = Compressible_Density()
    @test isbits(x)
    @test param_info(x).Equation === L"$\rho = \rho_0\exp(\beta*(P-P_0))$"
    @test isdimensional(x) === true

    x = MeltDependent_Density()
    @test isbits(x)
    @test param_info(x).Equation === L"$\rho =  \phi \rho_{\textrm{melt}} + (1-\phi) \\rho_{\textrm{solid}}$"
    @test isdimensional(x) === true

    x = T_Density()
    @test isbits(x)
    @test param_info(x).Equation === L"$\rho = \rho_0*(1 - \alpha*(T-T_0))$"
    @test isdimensional(x) === true

    x = BubbleFlow_Density()
    @test isbits(x)
    @test param_info(x).Equation === L"\rho = 1/((c_0-c)/rho_g + 1-(c_0-c)/\rho_m)"
    @test isdimensional(x) === true

    x = GasPyroclast_Density()
    @test isbits(x)
    @test param_info(x).Equation === L"\rho = \rho_g\delta + \rho_p(1 - \delta)"
    @test isdimensional(x) === true

    # This tests the MaterialParameters structure
    CharUnits_GEO = GEO_units(; viscosity = 1.0e19, length = 1000km)

    # Test autogenerated get_X() functions
    x1 = ConstantDensity(; ρ = 2900kg / m^3)
    @test x1.ρ.val == 2900
    @test GeoParams.get_ρ(x1) == 2900

    x1 = nondimensionalize(x1, CharUnits_GEO)
    @test x1.ρ.val ≈ 2.9e-16

    x2 = PT_Density()
    @test x2.α.val == 3.0e-5
    @test x2.ρ0.val == 2900.0
    @test GeoParams.get_α(x2) == 3.0e-5
    @test GeoParams.get_ρ0(x2) == 2900

    # Test the density calculations with units
    args = (P = 1.0e3MPa, T = 1000C)
    @test compute_density(x2, args) ≈ 5713.000000000001kg * m^-3
    @test x2(args) ≈ 5713.000000000001kg * m^-3
    @test derivative(x -> compute_density(x2, (P = 1.0e9, T = x)), 1.0e3) == -0.08700000000000001
    @test derivative(x -> compute_density(x2, (P = x, T = 1.0e3)), 1.0e9) == 2.9e-6

    # Test the density calculations with non-dimensionalized units
    x2 = nondimensionalize(x2, CharUnits_GEO)
    @test x2.T0.val ≈ 0.21454659702313156

    # Compute with density while specifying P & T (not used in case of )
    args = (P = 1.0, T = 1.0)
    @test compute_density(x2, args) ≈ 2.8419999999999996e-16
    @test x2(args) ≈ 2.8419999999999996e-16
    @test x2(; P = 1.0, T = 1.0) ≈ 2.8419999999999996e-16
    @test compute_density(x1, args) ≈ 2.9e-16
    @test compute_density(x1) ≈ 2.9e-16
    @test x1(args) ≈ 2.9e-16
    @test x1() ≈ 2.9e-16

    # test to allocations
    rho = [0.0]
    P = 1.0
    T = 1.0
    args = (P = P, T = T)

    # This allocates the first time it is called but not the second time
    # x = ConstantDensity()
    # num_alloc = @allocated compute_density!(rho, x, args)
    # @test num_alloc == 0

    #Test allocations using ρ alias
    ρ!(rho, x, args)
    num_alloc = @allocated ρ!(rho, x, args)
    @test num_alloc == 0

    # This does NOT allocate if I test this with @btime;
    #   yet it does while running the test here
    x = PT_Density()
    compute_density!(rho, x, args)
    num_alloc = @allocated compute_density!(rho, x, args)
    # @show num_alloc
    @test num_alloc == 0

    # This does NOT allocate if I test this with @btime;
    #   yet it does while running the test here
    x = Compressible_Density()
    @test GeoParams.get_P0(x) == x.P0.val
    @test GeoParams.get_β(x) == x.β.val
    @test GeoParams.get_ρ0(x) == x.ρ0.val
    compute_density!(rho, x, args)
    num_alloc = @allocated compute_density!(rho, x, args)
    # @show num_alloc
    @test num_alloc == 0

    @test derivative(x -> compute_density(Compressible_Density(), (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(Compressible_Density(), (P = x, T = args.T)), args.P) ≈ 2.90000290000145e-6 rtol = 1.0e-6

    # Read Phase diagram interpolation object
    fname = "test_data/Peridotite_dry.in"
    PD_data = PerpleX_LaMEM_Diagram(fname)
    @test PD_data.meltFrac(1500, 1.0e7) ≈ 0.2538048323727155
    @test PD_data.Rho(1500, 1.0e7) ≈ 3054.8671154189938
    @test PD_data.meltRho(1500, 1.0e7) ≈ 2669.0094526913545
    @test PD_data.rockRho(1500, 1.0e7) ≈ 3186.1092890687055

    args = (P = 1.0e7, T = 1500.0)
    @test compute_density(PD_data, args) ≈ 3054.8671154189938 # named tuple syntax
    @test compute_density(PD_data; P = 1.0e7, T = 1500.0) ≈ 3054.8671154189938 # optional parameter syntax

    #  test extractors for more complex data strutcs
    r = SetMaterialParams(;
        Name = "Crust",
        Phase = 1,
        Density = ConstantDensity(; ρ = 2900kg / m^3),
    )
    @test GeoParams.get_ρ(r) == 2900

    R = (
        r,
        SetMaterialParams(;
            Name = "Crust",
            Phase = 2,
            Density = ConstantDensity(; ρ = 2700kg / m^3),
        ),
    )
    @test GeoParams.get_ρ(R, 1) == 2900
    @test GeoParams.get_ρ(R, 2) == 2700
    @test GeoParams.get_ρ(R, SA[0.5, 0.5]) == 2800

    # Do the same but non-dimensionalize the result
    CharDim = GEO_units()
    PD_data1 = PerpleX_LaMEM_Diagram(fname; CharDim = CharDim)

    rho_ND = PD_data1.Rho(
        nondimensionalize(1500.0K, CharDim), nondimensionalize(1.0e8 * Pa, CharDim)
    )
    Vp_ND = PD_data1.Vp(
        nondimensionalize(1500.0K, CharDim), nondimensionalize(1.0e8 * Pa, CharDim)
    )
    Vs_ND = PD_data1.Vs(
        nondimensionalize(1500.0K, CharDim), nondimensionalize(1.0e8 * Pa, CharDim)
    )

    # redimensionalize and check with value from original structure that did not use non-dimensionalization
    @test ustrip(dimensionalize(rho_ND, kg / m^3, CharDim)) ≈ PD_data.Rho(1500.0, 1.0e8)
    @test ustrip(dimensionalize(Vp_ND, km / s, CharDim)) ≈ PD_data.Vp(1500.0, 1.0e8)
    @test ustrip(dimensionalize(Vs_ND, km / s, CharDim)) ≈ PD_data.Vs(1500.0, 1.0e8)

    # Test computation of density for the whole computational domain, using arrays
    MatParam = Vector{AbstractMaterialParamsStruct}(undef, 5)

    MatParam[1] = SetMaterialParams(;
        Name = "Mantle",
        Phase = 0,
        CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pa * s)),
        Density = PerpleX_LaMEM_Diagram("test_data/sediments_1.in"),
    )

    MatParam[2] = SetMaterialParams(;
        Name = "Crust",
        Phase = 1,
        CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pa * s)),
        Density = ConstantDensity(; ρ = 2900kg / m^3),
    )

    MatParam[3] = SetMaterialParams(;
        Name = "UpperCrust",
        Phase = 2,
        CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pa * s)),
        Density = PT_Density(),
    )
    MatParam[4] = SetMaterialParams(;
        Name = "UpperCrust",
        Phase = 3,
        CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pa * s)),
        Density = Compressible_Density(),
    )
    MatParam[5] = SetMaterialParams(;
        Name = "LowerCrust",
        Phase = 4,
        CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pa * s)),
        Density = Vector_Density(rho = fill(2900.0, 100)),
    )
    Mat_tup = Tuple(MatParam)  # create a tuple to avoid allocations

    MatParam1 = Vector{AbstractMaterialParamsStruct}(undef, 4)
    MatParam1[1] = SetMaterialParams(;
        Name = "Crust",
        Phase = 0,
        CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pas)),
        Density = ConstantDensity(; ρ = 2900kg / m^3),
    )
    MatParam1[2] = SetMaterialParams(;
        Name = "Lower Crust",
        Phase = 1,
        CreepLaws = (PowerlawViscous(; n = 5.0), LinearViscous(; η = 1.0e21Pas)),
        Density = Compressible_Density(; ρ0 = 3000kg / m^3),
    )
    MatParam1[3] = SetMaterialParams(;
        Name = "Lower Crust",
        Phase = 2,
        CreepLaws = LinearViscous(; η = 1.0e21Pas),
        Density = ConstantDensity(),
    )
    MatParam1[4] = SetMaterialParams(;
        Name = "Lower Crust",
        Phase = 3,
        CreepLaws = LinearViscous(; η = 1.0e21Pas),
        Density = ConstantDensity(),
    )
    Mat_tup1 = Tuple(MatParam1)

    # test computing material properties
    Phases = zeros(Int64, 400, 400)
    @views Phases[:, 20:end] .= 1
    @views Phases[:, 200:end] .= 2
    @views Phases[:, 300:end] .= 3
    @views Phases[:, 350:end] .= 4

    #Phases .= 2;
    rho = zeros(size(Phases))
    T = ones(size(Phases))
    P = fill(10.0, size(Phases))

    args = (P = P, T = T, index = fill(10, size(T)))

    compute_density!(rho, MatParam, Phases, args)

    # Test computing density when Mat_tup1 is provided as a tuple
    compute_density!(rho, Mat_tup1, Phases, args)
    num_alloc = @allocated compute_density!(rho, Mat_tup1, Phases, args)   #      287.416 μs (0 allocations: 0 bytes)
    @test sum(rho) / 400^2 ≈ 2575.250013499998
    # @test num_alloc ≤ 32

    #Same test using function alias
    rho = zeros(size(Phases))
    ρ!(rho, Mat_tup1, Phases, args)
    num_alloc = @allocated compute_density!(rho, Mat_tup1, Phases, args)
    @test sum(rho) / 400^2 ≈ 2575.250013499998
    # @test num_alloc ≤ 32

    # Test for single phase
    compute_density(MatParam, 1, (P = P[1], T = T[1]))

    # If we employ a phase diagram many allocations occur:
    compute_density!(rho, Mat_tup, Phases, args)   #        37.189 ms (1439489 allocations: 26.85 MiB)     - the allocations are from the phase diagram
    @test sum(rho) / 400^2 ≈ 2895.5241895725003

    # test computing material properties when we have PhaseRatios, instead of Phase numbers
    PhaseRatio = zeros(size(Phases)..., length(Mat_tup))
    for i in CartesianIndices(Phases)
        iz = Phases[i]
        I = CartesianIndex(i, iz + 1)
        PhaseRatio[I] = 1.0
    end

    compute_density!(rho, Mat_tup1, PhaseRatio, args)

    num_alloc = @allocated compute_density!(rho, Mat_tup1, PhaseRatio, args) #   136.776 μs (0 allocations: 0 bytes)
    @test sum(rho) / 400^2 ≈ 2575.250013499998
    @test num_alloc == 0           # for some reason this does indicate allocations but @btime does not

    # Test calling the routine with only pressure as input.
    # This is ok for Mat_tup1, as it only has constant & P-dependent densities.
    # Note, however, that if you have P & T dependent densities and do this it will use 0 as default value for T
    compute_density!(rho, Mat_tup1, PhaseRatio, (; P = P))
    @test sum(rho) / 400^2 ≈ 2575.250013499998

    # In case we only want to compute with T, do this:
    #  NOTE that in this example the results are actually wrong (as some functions require P as well)
    compute_density!(rho, Mat_tup, PhaseRatio, (P = zeros(size(T)), T = T, index = fill(10, size(T))))
    @test sum(rho) / 400^2 ≈ 2895.524175

    #Test computation of density given a single phase and P,T as scalars
    Phase, P, T = 0, 1.0, 1.0
    @test compute_density(Mat_tup1, Phase, (P = P[1], T = T[1])) == 2900.0

    # Local phase ratio density calculation
    args = (P = 0.0, T = 20.0)
    rheologies = (
        SetMaterialParams(;
            Name = "Crust",
            Phase = 0,
            CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pas)),
            Density = ConstantDensity(; ρ = 2900kg / m^3),
        ),
        SetMaterialParams(;
            Name = "Lower Crust",
            Phase = 1,
            CreepLaws = (PowerlawViscous(; n = 5.0), LinearViscous(; η = 1.0e21Pas)),
            Density = Compressible_Density(; ρ0 = 3000kg / m^3),
        ),
    )

    PhaseRatio = (0.5, 0.5)
    @test 2950.0e0 == compute_density_ratio(PhaseRatio, rheologies, args)
    @test 2950.0e0 == compute_density(rheologies, PhaseRatio, args)

    SvPhaseRatio = SA[0.5, 0.5]
    @test 2950.0e0 == compute_density_ratio(SvPhaseRatio, rheologies, args)
    @test 2950.0e0 == compute_density(rheologies, SvPhaseRatio, args)

    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(rheologies, PhaseRatio, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = x, T = args.T)), args.P) == 1.5e-6
    @test derivative(x -> compute_density(rheologies, PhaseRatio, (P = x, T = args.T)), args.P) == 1.5e-6

    # Melt-dependent density ----------------------------------
    CharUnits_GEO = GEO_units(; viscosity = 1.0e19, length = 1000km)
    x_D = MeltDependent_Density(ρmelt = T_Density(ρ0 = 2200kg / m^3))
    x_ND = nondimensionalize(x_D, CharUnits_GEO)
    @test isdimensional(x_D) == true
    @test isdimensional(x_ND) == false

    args = (P = 0.0, T = 20.0 + 273.15, ϕ = 0.5)
    ρsolid = compute_density(x_D.ρsolid, args)
    ρmelt = compute_density(x_D.ρmelt, args)
    ρ = compute_density(x_D, args)

    @test ρsolid == 2900.0
    @test ρmelt ≈ 2198.68
    @test ρ == (1 - args.ϕ) * ρsolid + args.ϕ * ρmelt

    x = MeltDependent_Density(
        ρsolid = PT_Density(α = 1.0e-3),
        ρmelt = PT_Density(α = 1.0e-2),
    )
    @test GeoParams.get_α(x, (; ϕ = 1)) == 1.0e-2
    @test GeoParams.get_α(x, (; ϕ = 0)) == 1.0e-3
    @test GeoParams.get_α(x, (; ϕ = 0.5)) == 0.0055

    @test derivative(x -> compute_density(x_D.ρsolid, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D.ρsolid, (P = x, T = args.T)), args.P) == 0.0
    @test derivative(x -> compute_density(x_D.ρmelt, (P = args.P, T = x)), args.T) == -0.066
    @test derivative(x -> compute_density(x_D.ρmelt, (P = x, T = args.T)), args.P) == 0.0
    @test derivative(x -> compute_density(x_D, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D, (P = x, T = args.T)), args.P) == 0.0

    rheologies = (
        SetMaterialParams(;
            Name = "Crust",
            Phase = 0,
            CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pas)),
            Density = MeltDependent_Density(ρmelt = T_Density(ρ0 = 2200kg / m^3)),
        ),
        SetMaterialParams(;
            Name = "Lower Crust",
            Phase = 1,
            CreepLaws = (PowerlawViscous(; n = 5.0), LinearViscous(; η = 1.0e21Pas)),
            Density = MeltDependent_Density(ρmelt = T_Density(ρ0 = 2200kg / m^3)),
        ),
    )
    PhaseRatio = (0.5, 0.5)

    args = (P = 0.0, T = 20.0 + 273.15, ϕ = 0.5)
    @test compute_density_ratio(PhaseRatio, rheologies, args) == compute_density(rheologies, PhaseRatio, args) == ρ

    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = x, T = args.T)), args.P) == 0.0

    rho = zeros(size(Phases))
    T = fill(20.0 + 273.15, size(Phases))
    P = fill(10.0, size(Phases))
    ϕ = fill(0.5, size(Phases))

    args_vec = (P = P, T = T, ϕ = ϕ)

    compute_density!(rho, rheologies, Phases, args_vec)
    @test rho[1] ≈ ρ
    # Conduit densities ----------------------------------------
    # BubbleFlow Density
    CharUnits_GEO = GEO_units(; viscosity = 1.0e19, length = 1000km)
    x_D = BubbleFlow_Density(c0 = 0.1)
    x_ND = nondimensionalize(x_D, CharUnits_GEO)
    @test isdimensional(x_D) == true
    @test isdimensional(x_ND) == false

    args = (P = 1.0e8, T = 0.0 + 273.15)
    ρmelt = compute_density(x_D.ρmelt, args)
    ρgas = compute_density(x_D.ρgas, args)
    ρ = compute_density(x_D, args)

    cutoff = 0.1^2 / 4.1e-6^2
    c_theoretical = 4.1e-6 * sqrt(args.P)
    @test ρmelt ≈ 2200.0
    @test ρgas ≈ 1.0
    @test ρ ≈ inv((x_D.c0 - c_theoretical) / ρgas + (1 - (x_D.c0 - c_theoretical)) / ρmelt)

    x = BubbleFlow_Density(
        ρmelt = PT_Density(α = 1.0e-3),
        ρgas = PT_Density(α = 1.0e-2),
    )
    @test GeoParams.get_α(x, (; P = 0.0e0)) == 1.0e-3


    @test derivative(x -> compute_density(x_D.ρmelt, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D.ρmelt, (P = x, T = args.T)), args.P) == 0.0
    @test derivative(x -> compute_density(x_D.ρgas, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D.ρgas, (P = x, T = args.T)), args.P) == 0.0
    @test derivative(x -> compute_density(x_D, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D, (P = x, T = args.T)), args.P) ≈ 5.8020059036332765e-8 rtol = 1.0e-6

    rheologies = (
        SetMaterialParams(;
            Name = "Crust",
            Phase = 0,
            CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pas)),
            Density = BubbleFlow_Density(c0 = 0.1),
        ),
        SetMaterialParams(;
            Name = "Lower Crust",
            Phase = 1,
            CreepLaws = (PowerlawViscous(; n = 5.0), LinearViscous(; η = 1.0e21Pas)),
            Density = BubbleFlow_Density(c0 = 0.1),
        ),
    )
    PhaseRatio = (0.5, 0.5)

    args = (P = 1.0e8, T = 0.0 + 273.15)
    @test compute_density_ratio(PhaseRatio, rheologies, args) == compute_density(rheologies, PhaseRatio, args) == ρ

    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = x, T = args.T)), args.P) ≈ 5.8020059036332765e-8 rtol = 1.0e-6

    rho = zeros(size(Phases))
    T = fill(20.0 + 273.15, size(Phases))
    P = fill(1.0e8, size(Phases))

    args_vec = (P = P, T = T)

    compute_density!(rho, rheologies, Phases, args_vec)
    @test rho[1] ≈ ρ


    # GasPyroclast Density
    CharUnits_GEO = GEO_units(; viscosity = 1.0e19, length = 1000km)
    x_D = GasPyroclast_Density(δ = 0.05, β = 0.05)
    x_ND = nondimensionalize(x_D, CharUnits_GEO)
    @test isdimensional(x_D) == true
    @test isdimensional(x_ND) == false

    args = (P = 1.0e8, T = 0.0 + 273.15)

    ρmelt = compute_density(x_D.ρmelt, args)
    ρgas = compute_density(x_D.ρgas, args)
    ρ = compute_density(x_D, args)

    @test ρmelt ≈ 2200.0
    @test ρgas ≈ 1.0
    @test ρ ≈ x_D.δ * ρgas + ρmelt * (1 - x_D.δ)

    x = GasPyroclast_Density(
        ρmelt = PT_Density(α = 1.0e-3),
        ρgas = PT_Density(α = 1.0e-2),
    )
    @test GeoParams.get_α(x, (; P = 0.0e0)) == 1.0e-3


    @test derivative(x -> compute_density(x_D.ρmelt, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D.ρmelt, (P = x, T = args.T)), args.P) == 0.0
    @test derivative(x -> compute_density(x_D.ρgas, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D.ρgas, (P = x, T = args.T)), args.P) == 0.0
    @test derivative(x -> compute_density(x_D, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density(x_D, (P = x, T = args.T)), args.P) == 0.0

    rheologies = (
        SetMaterialParams(;
            Name = "Crust",
            Phase = 0,
            CreepLaws = (PowerlawViscous(), LinearViscous(; η = 1.0e23Pas)),
            Density = GasPyroclast_Density(δ = 0.05, β = 0.05),
        ),
        SetMaterialParams(;
            Name = "Lower Crust",
            Phase = 1,
            CreepLaws = (PowerlawViscous(; n = 5.0), LinearViscous(; η = 1.0e21Pas)),
            Density = GasPyroclast_Density(δ = 0.05, β = 0.05),
        ),
    )

    PhaseRatio = (0.5, 0.5)
    args = (P = 1.0e8, T = 0.0 + 273.15)
    @test compute_density_ratio(PhaseRatio, rheologies, args) == compute_density(rheologies, PhaseRatio, args) == ρ

    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = args.P, T = x)), args.T) == 0.0
    @test derivative(x -> compute_density_ratio(PhaseRatio, rheologies, (P = x, T = args.T)), args.P) == 0.0

    rho = zeros(size(Phases))
    T = fill(20.0 + 273.15, size(Phases))
    P = fill(1.0e8, size(Phases))

    args_vec = (P = P, T = T)

    compute_density!(rho, rheologies, Phases, args_vec)
    @test rho[1] ≈ ρ
end
